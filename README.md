# interview

## Computer Organization and Architecture
* How to compare two floats?
* Compare Global, Stack and Heap.
* Compare pass by value, reference and address.
## Web 
* Different between session, cookie and localstorage? 
* Compare WebSocket, Polling, Long-Polling and Streaming.
## Front-end 
* How to improve the perfornamce? 
* Explain event bubbling.
## CSS 
* Explain pseudo elements
## JavaScript  
* Explain "this".
* Explain Lifetime of JavaScript variables.
* Implement the adder function to pass all assert 
```
var adder = function(n){......}
var add_one = adder(1);
var add_two = adder(2);	
assert(add_one(5) == 6); 
assert(add_two(8) == 10);   
```
* Equal or not? 
```
console.log( 0 == false )
console.log( 0 === false )
if( {} ) alert(true); 						
if( [] ) alert(true); 
if( “” ) alert(true);
```
* Different between Call, Apply and Bind ?
## Java 
* Different between Overloading and Overriding.
* Does Java support multiple inheritance? If not, can we simulate it?
## SQL
* Explain join.
## OS
* Different between Process and Thread.
* Explain deadlock.
* Explain Race Condition and how to avoid it?
## Data Structure & Algorithm
* Given an array and a value, remove all elements of that > value in place* and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length. And the all elements of the array in new length should <= value. *(in place: You can’t create new array to store result, just use original array)
* Given two binary strings, return their sum (also a binary string). For example, a = "11" b = "1" Return "100". You can assume "0" < a, b, a+b < “11111111111111111111” (2^20-1)
* Multiple by 8 without using multiplication or addition
* Suppose you have an array of 1000 integers. The integers are in random order, but you know each of the integers is between 1 and 5000 (inclusive). In addition, each number appears only once in the array. Assume that you can access each element of the array only once. Describe an algorithm to sort it. If you used auxiliary storage in your algorithm, can you find an algorithm that remains O(n) space complexity?
